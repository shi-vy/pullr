<!DOCTYPE html>
<html>
<head>
  <title>üé¨ Pullr Dashboard</title>
  <link rel="stylesheet" href="/static/styles.css?v={{ version }}">
</head>
<body>
  <h1>üé¨ Pullr Dashboard</h1>

  <form id="add-form">
    <input type="text" id="magnet-input" name="magnet" placeholder="Enter magnet link" required />
    <button type="submit">Add</button>
  </form>

  <h2>üì• Manual Downloads</h2>
  <table>
    <thead>
      <tr><th>Queue</th><th>ID</th><th>Status</th></tr>
    </thead>
    <tbody id="manualTorrentTable"></tbody>
  </table>

  <h2>üîÑ Auto-Detected Downloads</h2>
  <table>
    <thead>
      <tr><th>Queue</th><th>Name</th><th>Status</th></tr>
    </thead>
    <tbody id="externalTorrentTable"></tbody>
  </table>

  <div id="fileModal" class="modal" style="display:none;">
    <div class="modal-content">
      <h2 id="modalTitle">Select Files</h2>
      <form id="fileForm">
        <div id="fileList"></div>
        <div id="folderNameSection" style="margin: 20px 0; display:none;">
          <label for="folderNameInput" style="display:block; margin-bottom:8px; color:#ccc;">
            Custom Folder Name <span style="color:#ff6680;">*</span> (required for multiple files):
          </label>
          <input type="text" id="folderNameInput" name="folder_name"
                 placeholder="e.g., 'Season 1' or 'Movie Collection'"
                 style="width:100%; padding:10px; background:#252525; color:#eee; border:1px solid #444; border-radius:6px;">
        </div>
        <div class="button-row">
          <button type="button" id="selectAllBtn" class="blue">Select All</button>
          <button type="submit" id="downloadSelectedBtn" class="green">Download Selected</button>
          <button type="button" id="cancelBtn" class="gray">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <script>
  // --- handle form submission without reload ---
  const form = document.getElementById('add-form');
  const input = document.getElementById('magnet-input');

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const magnet = input.value.trim();
    if (!magnet) return;

    try {
      const resp = await fetch('/add', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({ magnet })
      });
      const data = await resp.json();
      console.log('Torrent added:', data);
    } catch (err) {
      console.error('Error adding torrent:', err);
    }

    input.value = '';
  });

  // --- live updates via websocket ---
  const manualTableBody = document.getElementById('manualTorrentTable');
  const externalTableBody = document.getElementById('externalTorrentTable');
  const colorMap = {
      WAITING_FOR_SELECTION: "gold",
      DOWNLOADING_FROM_REALDEBRID: "lightgreen",
      AVAILABLE_FROM_REALDEBRID: "lightblue",
      WAITING_IN_QUEUE: "orange",
      TRANSFERRING_TO_MEDIA_SERVER: "violet",
      FINISHED: "lime",
      FAILED: "red"
    };
  const ws = new WebSocket("ws://" + window.location.host + "/ws");

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log("Received update:", data);

    // Handle both old format (direct torrents object) and new format (manual/external)
    const manualTorrents = data.manual || {};
    const externalTorrents = data.external || {};

    // Populate manual torrents table
    populateTable(manualTableBody, manualTorrents, false);

    // Populate external torrents table
    populateTable(externalTableBody, externalTorrents, true);
  };

  function populateTable(tableBody, torrents, isExternal) {
    tableBody.innerHTML = "";

    // Sort by queue position (active first, then by queue position)
    const sortedEntries = Object.entries(torrents).sort((a, b) => {
      const [idA, infoA] = a;
      const [idB, infoB] = b;

      // Active torrent always first
      if (infoA.is_active && !infoB.is_active) return -1;
      if (!infoA.is_active && infoB.is_active) return 1;

      // Then by queue position
      const queueA = infoA.queue_position || 999999;
      const queueB = infoB.queue_position || 999999;
      return queueA - queueB;
    });

    for (const [id, info] of sortedEntries) {
      const row = document.createElement("tr");
      const stateName = info.state.replace("TorrentState.", "");

      // Queue position display
      let queueDisplay = "";
      if (info.is_active) {
        queueDisplay = "‚ñ∂Ô∏è Active";
      } else if (info.queue_position) {
        queueDisplay = `#${info.queue_position}`;
      } else {
        queueDisplay = "‚Äî";
      }

      // Display name or files
      let displayName = isExternal ? info.name : id;
      if (info.selected_files && info.selected_files.length > 0) {
        displayName = info.selected_files.join('<br>');
      }

      // Format progress display if downloading
      const progressDisplay =
        stateName === "DOWNLOADING_FROM_REALDEBRID" && info.progress > 0
          ? ` (${info.progress.toFixed(1)}%)`
          : "";

      let stateHTML = `<span style="color:${colorMap[stateName] || "white"}">${stateName}${progressDisplay}</span>`;

      // Show error message if present
      if (info.error_message) {
        stateHTML += `<br><span style="color:red; font-size:0.9em;">‚ö†Ô∏è ${info.error_message}</span>`;
      }

      // Render file selection UI if waiting for selection (manual torrents only)
      if (!isExternal && stateName === "WAITING_FOR_SELECTION" && info.files && info.files.length > 0) {
        stateHTML += `
          <button onclick="openFileModal('${id}', ${JSON.stringify(info.files).replace(/"/g, "&quot;")})">
            Select Files
          </button>`;
      }

      row.innerHTML = `<td>${queueDisplay}</td><td>${displayName}</td><td>${stateHTML}</td>`;
      tableBody.appendChild(row);
    }

    // Show "No torrents" message if table is empty
    if (sortedEntries.length === 0) {
      const row = document.createElement("tr");
      row.innerHTML = `<td colspan="3" style="text-align:center; color:#666; font-style:italic;">No torrents yet</td>`;
      tableBody.appendChild(row);
    }
  }

  ws.onclose = () => {
    console.log("WebSocket closed. Reconnecting...");
    setTimeout(() => location.reload(), 2000);
  };

  const modal = document.getElementById("fileModal");
  const modalTitle = document.getElementById("modalTitle");
  const fileList = document.getElementById("fileList");
  const fileForm = document.getElementById("fileForm");
  const folderNameInput = document.getElementById("folderNameInput");
  const folderNameSection = document.getElementById("folderNameSection");
  const downloadSelectedBtn = document.getElementById("downloadSelectedBtn");
  const selectAllBtn = document.getElementById("selectAllBtn");
  let currentTorrentId = null;
  let totalFiles = 0;

  function openFileModal(torrentId, files) {
    currentTorrentId = torrentId;
    totalFiles = files.length;
    modalTitle.textContent = `Select Files for ${torrentId}`;

    fileList.innerHTML = files.map((f) => `
      <div class="file-row">
        <input type="checkbox" name="file" value="${f.id}" id="cb_${f.id}" class="file-checkbox">
        <label for="cb_${f.id}" class="file-details">
          <span class="filename">${f.name}</span>
          <span class="filesize">${(f.bytes / 1e6).toFixed(1)} MB</span>
        </label>
      </div>
    `).join("");

    folderNameInput.value = "";

    // Show folder name section only if more than 1 file total
    if (totalFiles > 1) {
      folderNameSection.style.display = "block";
    } else {
      folderNameSection.style.display = "none";
    }

    // Add event listeners to checkboxes to update button states
    document.querySelectorAll(".file-checkbox").forEach(cb => {
      cb.addEventListener("change", updateButtonStates);
    });

    // Add event listener to folder name input
    folderNameInput.addEventListener("input", updateButtonStates);

    modal.style.display = "block";
    updateButtonStates();
  }

  function updateButtonStates() {
    const selectedCount = document.querySelectorAll("#fileList input:checked").length;
    const folderName = folderNameInput.value.trim();

    // If multiple files selected, require folder name
    if (selectedCount > 1) {
      const isValid = folderName.length > 0;
      downloadSelectedBtn.disabled = !isValid;
      downloadSelectedBtn.style.opacity = isValid ? "1" : "0.5";
      downloadSelectedBtn.style.cursor = isValid ? "pointer" : "not-allowed";
    } else {
      // Single file or no selection - no folder name needed for submit button
      downloadSelectedBtn.disabled = selectedCount === 0;
      downloadSelectedBtn.style.opacity = selectedCount > 0 ? "1" : "0.5";
      downloadSelectedBtn.style.cursor = selectedCount > 0 ? "pointer" : "not-allowed";
    }
  }

  document.getElementById("selectAllBtn").onclick = () => {
    // Select all checkboxes
    document.querySelectorAll(".file-checkbox").forEach(cb => {
      cb.checked = true;
    });

    // Update button states after selecting all
    updateButtonStates();

    // Focus on folder name input if multiple files
    if (totalFiles > 1) {
      folderNameInput.focus();
    }
  };

  document.getElementById("cancelBtn").onclick = () => {
    modal.style.display = "none";
    fileList.innerHTML = "";
    folderNameInput.value = "";
    folderNameSection.style.display = "none";
    currentTorrentId = null;
    totalFiles = 0;
  };

  fileForm.onsubmit = (e) => {
    e.preventDefault();
    const selected = Array.from(document.querySelectorAll("#fileList input:checked"))
      .map(cb => cb.value)
      .join(",");

    if (!selected) {
      alert("Please select at least one file!");
      return;
    }

    const selectedCount = document.querySelectorAll("#fileList input:checked").length;
    const folderName = folderNameInput.value.trim();

    // Validate: if multiple files selected, folder name is required
    if (selectedCount > 1 && !folderName) {
      alert("Please provide a custom folder name for multiple files!");
      return;
    }

    const params = new URLSearchParams({ files: selected });
    if (folderName && selectedCount > 1) {
      params.append("folder_name", folderName);
    }

    fetch(`/select_files/${currentTorrentId}`, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: params
    })
      .then(() => {
        console.log(`Selected files [${selected}] for ${currentTorrentId}`);
        modal.style.display = "none";
        fileList.innerHTML = "";
        folderNameInput.value = "";
        folderNameSection.style.display = "none";
        currentTorrentId = null;
        totalFiles = 0;
      })
      .catch(err => alert("File selection failed: " + err));
  };
  </script>

  <footer id="version-footer" style="text-align:center; margin-top:1em; color:#666; font-size:0.9em;">
    Loading version info...
  </footer>

  <script>
  async function showVersion() {
    try {
      const resp = await fetch('/version');
      const data = await resp.json();
      const footer = document.getElementById('version-footer');
      footer.textContent = `Pullr ‚Äì ${data.branch} @ ${data.commit}`;
    } catch (e) {
      console.error("Failed to fetch version info:", e);
    }
  }
  showVersion();
  </script>

</body>
</html>