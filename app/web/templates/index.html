<!DOCTYPE html>
<html>
<head>
  <title>üé¨ Pullr Dashboard</title>
  <link rel="stylesheet" href="/static/styles.css?v={{ version }}">
</head>
<body>
  <h1>üé¨ Pullr Dashboard</h1>

  <form id="add-form">
    <input type="text" id="magnet-input" name="magnet" placeholder="Enter magnet link" required />
    <button type="submit">Add</button>
  </form>

  <div style="margin: 16px 0; padding: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px;">
    <label style="display: flex; align-items: center; cursor: pointer; user-select: none;">
      <input type="checkbox" id="quickDownloadToggle" checked style="width: 20px; height: 20px; margin-right: 12px; cursor: pointer;">
      <div>
        <span style="font-weight: bold; color: #ff6680;">‚ö° Quick Download Mode</span>
        <p style="margin: 4px 0 0 0; color: #888; font-size: 0.9em;">
          Automatically download single-file torrents and torrents with only media files.
          Disable to manually confirm all downloads and set options.
        </p>
      </div>
    </label>
  </div>

  <h2>üì• Manual Downloads</h2>
  <table>
    <thead>
      <tr><th>Queue</th><th>ID</th><th>Status</th></tr>
    </thead>
    <tbody id="manualTorrentTable"></tbody>
  </table>

  <h2>üîÑ Auto-Detected Downloads</h2>
  <table>
    <thead>
      <tr><th>Queue</th><th>Name</th><th>Status</th></tr>
    </thead>
    <tbody id="externalTorrentTable"></tbody>
  </table>

  <div id="fileModal" class="modal" style="display:none;">
    <div class="modal-content">
      <h2 id="modalTitle">Select Files</h2>
      <form id="fileForm">
        <div id="fileList"></div>
        <div id="folderNameSection" style="margin: 20px 0; display:none;">
          <label for="folderNameInput" style="display:block; margin-bottom:8px; color:#ccc;">
            Custom Folder Name <span style="color:#ff6680;">*</span> (required for multiple files):
          </label>
          <input type="text" id="folderNameInput" name="folder_name"
                 placeholder="e.g., 'Season 1' or 'Movie Collection'"
                 style="width:100%; padding:10px; background:#252525; color:#eee; border:1px solid #444; border-radius:6px;">
        </div>

        <div id="optionsSection" style="margin: 20px 0;">
          <button type="button" id="toggleOptionsBtn" class="gray" style="width:100%; text-align:left; padding:12px; font-size:0.95em;">
            ‚öôÔ∏è Options (click to expand)
          </button>
          <div id="optionsContent" style="display:none; margin-top:12px; padding:16px; background:#1f1f1f; border:1px solid #333; border-radius:6px;">
            <label for="stripPatternInput" style="display:block; margin-bottom:8px; color:#ccc;">
              Strip Pattern from Filenames:
            </label>
            <input type="text" id="stripPatternInput" name="strip_pattern"
                   placeholder="e.g., '[Judas]' or '[SubsPlease]'"
                   style="width:100%; padding:10px; background:#252525; color:#eee; border:1px solid #444; border-radius:6px; margin-bottom:8px;">
            <p style="color:#888; font-size:0.85em; margin:0;">
              This pattern will be removed from the start of each filename, along with any trailing spaces.
              Example: "[Judas] Video.mkv" becomes "Video.mkv"
            </p>
          </div>
        </div>

        <div class="button-row">
          <button type="button" id="selectAllBtn" class="blue">Select All</button>
          <button type="submit" id="downloadSelectedBtn" class="green">Download Selected</button>
          <button type="button" id="cancelBtn" class="gray">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <script>
  // --- Quick Download Mode State (persisted in localStorage) ---
  const quickDownloadToggle = document.getElementById('quickDownloadToggle');

  // Load saved preference or default to true
  const savedQuickDownload = localStorage.getItem('quickDownloadMode');
  if (savedQuickDownload !== null) {
    quickDownloadToggle.checked = savedQuickDownload === 'true';
  }

  // Save preference when changed
  quickDownloadToggle.addEventListener('change', () => {
    localStorage.setItem('quickDownloadMode', quickDownloadToggle.checked);
    console.log('Quick Download Mode:', quickDownloadToggle.checked ? 'enabled' : 'disabled');
  });

  // --- handle form submission without reload ---
  const form = document.getElementById('add-form');
  const input = document.getElementById('magnet-input');

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const magnet = input.value.trim();
    if (!magnet) return;

    try {
      const resp = await fetch('/add', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          magnet: magnet,
          quick_download: quickDownloadToggle.checked.toString()
        })
      });
      const data = await resp.json();
      console.log('Torrent added:', data);
    } catch (err) {
      console.error('Error adding torrent:', err);
    }

    input.value = '';
  });

  // --- live updates via websocket ---
  const manualTableBody = document.getElementById('manualTorrentTable');
  const externalTableBody = document.getElementById('externalTorrentTable');
  const colorMap = {
      WAITING_FOR_SELECTION: "gold",
      DOWNLOADING_FROM_REALDEBRID: "lightgreen",
      AVAILABLE_FROM_REALDEBRID: "lightblue",
      WAITING_IN_QUEUE: "orange",
      TRANSFERRING_TO_MEDIA_SERVER: "violet",
      FINISHED: "lime",
      FAILED: "red"
    };
  const ws = new WebSocket("ws://" + window.location.host + "/ws");

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);

    // Handle both old format (direct torrents object) and new format (manual/external)
    const manualTorrents = data.manual || {};
    const externalTorrents = data.external || {};

    // Populate manual torrents table
    populateTable(manualTableBody, manualTorrents, false);

    // Populate external torrents table
    populateTable(externalTableBody, externalTorrents, true);
  };

  function populateTable(tableBody, torrents, isExternal) {
    tableBody.innerHTML = "";

    // Sort by queue position (active first, then by queue position)
    const sortedEntries = Object.entries(torrents).sort((a, b) => {
      const [idA, infoA] = a;
      const [idB, infoB] = b;

      // Active torrent always first
      if (infoA.is_active && !infoB.is_active) return -1;
      if (!infoA.is_active && infoB.is_active) return 1;

      // Then by queue position
      const queueA = infoA.queue_position || 999999;
      const queueB = infoB.queue_position || 999999;
      return queueA - queueB;
    });

    for (const [id, info] of sortedEntries) {
      const row = document.createElement("tr");
      const stateName = info.state.replace("TorrentState.", "");

      // Queue position display
      let queueDisplay = "";
      if (info.is_active) {
        queueDisplay = "‚ñ∂Ô∏è Active";
      } else if (info.queue_position) {
        queueDisplay = `#${info.queue_position}`;
      } else {
        queueDisplay = "‚Äî";
      }

      // Display name or files
      let displayName = isExternal ? info.name : id;
      if (info.selected_files && info.selected_files.length > 0) {
        displayName = info.selected_files.join('<br>');
      }

      // Format progress display if downloading
      const progressDisplay =
        stateName === "DOWNLOADING_FROM_REALDEBRID" && info.progress > 0
          ? ` (${info.progress.toFixed(1)}%)`
          : "";

      let stateHTML = `<span style="color:${colorMap[stateName] || "white"}">${stateName}${progressDisplay}</span>`;

      // Show TMDB Badge if present
      if (info.tmdb_id) {
          stateHTML += `<br><span style="color:#4caf50; font-size:0.8em; border:1px solid #4caf50; border-radius:4px; padding:1px 4px; margin-top:2px; display:inline-block;">TAGGED: ${info.tmdb_id}</span>`;
      }

      // Show error message if present
      if (info.error_message) {
        stateHTML += `<br><span style="color:red; font-size:0.9em;">‚ö†Ô∏è ${info.error_message}</span>`;
      }

      // --- BUTTON LOGIC ---

      // 1. Manual Selection Button (Manual torrents only)
      if (!isExternal && stateName === "WAITING_FOR_SELECTION" && info.files && info.files.length > 0) {
        stateHTML += `
          <div style="margin-top:4px;">
            <button onclick="openFileModal('${id}', ${JSON.stringify(info.files).replace(/"/g, "&quot;")})">
                Select Files
            </button>
          </div>`;
      }

      // 2. Add Metadata Button (External torrents only)
      // Show this button if it's external and NOT finished/failed yet
      if (isExternal && stateName !== "FINISHED" && stateName !== "FAILED") {
         stateHTML += `
            <div style="margin-top:4px;">
                <button onclick="addMetadata('${id}')" style="font-size:0.8em; padding:2px 6px; background:#444; border:1px solid #666; color:#eee; cursor:pointer;">
                    ${info.tmdb_id ? '‚úèÔ∏è Edit TMDB' : '‚ûï Add TMDB'}
                </button>
            </div>
         `;
      }

      row.innerHTML = `<td>${queueDisplay}</td><td>${displayName}</td><td>${stateHTML}</td>`;
      tableBody.appendChild(row);
    }

    // Show "No torrents" message if table is empty
    if (sortedEntries.length === 0) {
      const row = document.createElement("tr");
      row.innerHTML = `<td colspan="3" style="text-align:center; color:#666; font-style:italic;">No torrents yet</td>`;
      tableBody.appendChild(row);
    }
  }

  // --- Metadata Function ---
  async function addMetadata(torrentId) {
      const tmdbId = prompt("Enter TMDB ID (e.g., 12345):");
      if (tmdbId) {
          try {
              const resp = await fetch(`/set_metadata/${torrentId}`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                  body: new URLSearchParams({ tmdb_id: tmdbId })
              });
              const data = await resp.json();
              if(data.status === 'ok') {
                  console.log("Metadata updated");
                  // No need to reload, WebSocket will push the update
              } else {
                  alert("Failed to update: " + data.message);
              }
          } catch (e) {
              console.error(e);
              alert("Error updating metadata");
          }
      }
  }

  ws.onclose = () => {
    console.log("WebSocket closed. Reconnecting...");
    setTimeout(() => location.reload(), 2000);
  };

  const modal = document.getElementById("fileModal");
  const modalTitle = document.getElementById("modalTitle");
  const fileList = document.getElementById("fileList");
  const fileForm = document.getElementById("fileForm");
  const folderNameInput = document.getElementById("folderNameInput");
  const folderNameSection = document.getElementById("folderNameSection");
  const stripPatternInput = document.getElementById("stripPatternInput");
  const toggleOptionsBtn = document.getElementById("toggleOptionsBtn");
  const optionsContent = document.getElementById("optionsContent");
  const downloadSelectedBtn = document.getElementById("downloadSelectedBtn");
  const selectAllBtn = document.getElementById("selectAllBtn");
  let currentTorrentId = null;
  let totalFiles = 0;

  // Toggle options section
  toggleOptionsBtn.addEventListener("click", () => {
    const isHidden = optionsContent.style.display === "none";
    optionsContent.style.display = isHidden ? "block" : "none";
    toggleOptionsBtn.textContent = isHidden ? "‚öôÔ∏è Options (click to collapse)" : "‚öôÔ∏è Options (click to expand)";
  });

  function openFileModal(torrentId, files) {
    currentTorrentId = torrentId;
    totalFiles = files.length;
    modalTitle.textContent = `Select Files for ${torrentId}`;

    fileList.innerHTML = files.map((f) => `
      <div class="file-row">
        <input type="checkbox" name="file" value="${f.id}" id="cb_${f.id}" class="file-checkbox">
        <label for="cb_${f.id}" class="file-details">
          <span class="filename">${f.name}</span>
          <span class="filesize">${(f.bytes / 1e6).toFixed(1)} MB</span>
        </label>
      </div>
    `).join("");

    folderNameInput.value = "";
    stripPatternInput.value = "";

    // Reset options section to collapsed
    optionsContent.style.display = "none";
    toggleOptionsBtn.textContent = "‚öôÔ∏è Options (click to expand)";

    // Show folder name section only if more than 1 file total
    if (totalFiles > 1) {
      folderNameSection.style.display = "block";
    } else {
      folderNameSection.style.display = "none";
    }

    // Add event listeners to checkboxes to update button states
    document.querySelectorAll(".file-checkbox").forEach(cb => {
      cb.addEventListener("change", updateButtonStates);
    });

    // Add event listener to folder name input
    folderNameInput.addEventListener("input", updateButtonStates);

    modal.style.display = "block";
    updateButtonStates();
  }

  function updateButtonStates() {
    const selectedCount = document.querySelectorAll("#fileList input:checked").length;
    const folderName = folderNameInput.value.trim();

    // If multiple files selected, require folder name
    if (selectedCount > 1) {
      const isValid = folderName.length > 0;
      downloadSelectedBtn.disabled = !isValid;
      downloadSelectedBtn.style.opacity = isValid ? "1" : "0.5";
      downloadSelectedBtn.style.cursor = isValid ? "pointer" : "not-allowed";
    } else {
      // Single file or no selection - no folder name needed for submit button
      downloadSelectedBtn.disabled = selectedCount === 0;
      downloadSelectedBtn.style.opacity = selectedCount > 0 ? "1" : "0.5";
      downloadSelectedBtn.style.cursor = selectedCount > 0 ? "pointer" : "not-allowed";
    }
  }

  document.getElementById("selectAllBtn").onclick = () => {
    // Select all checkboxes
    document.querySelectorAll(".file-checkbox").forEach(cb => {
      cb.checked = true;
    });

    // Update button states after selecting all
    updateButtonStates();

    // Focus on folder name input if multiple files
    if (totalFiles > 1) {
      folderNameInput.focus();
    }
  };

  document.getElementById("cancelBtn").onclick = () => {
    modal.style.display = "none";
    fileList.innerHTML = "";
    folderNameInput.value = "";
    stripPatternInput.value = "";
    folderNameSection.style.display = "none";
    optionsContent.style.display = "none";
    toggleOptionsBtn.textContent = "‚öôÔ∏è Options (click to expand)";
    currentTorrentId = null;
    totalFiles = 0;
  };

  fileForm.onsubmit = (e) => {
    e.preventDefault();
    const selected = Array.from(document.querySelectorAll("#fileList input:checked"))
      .map(cb => cb.value)
      .join(",");

    if (!selected) {
      alert("Please select at least one file!");
      return;
    }

    const selectedCount = document.querySelectorAll("#fileList input:checked").length;
    const folderName = folderNameInput.value.trim();
    const stripPattern = stripPatternInput.value.trim();

    // Validate: if multiple files selected, folder name is required
    if (selectedCount > 1 && !folderName) {
      alert("Please provide a custom folder name for multiple files!");
      return;
    }

    const params = new URLSearchParams({ files: selected });
    if (folderName && selectedCount > 1) {
      params.append("folder_name", folderName);
    }
    if (stripPattern) {
      params.append("strip_pattern", stripPattern);
    }

    fetch(`/select_files/${currentTorrentId}`, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: params
    })
      .then(() => {
        console.log(`Selected files [${selected}] for ${currentTorrentId}`);
        if (stripPattern) {
          console.log(`Applied strip pattern: ${stripPattern}`);
        }
        modal.style.display = "none";
        fileList.innerHTML = "";
        folderNameInput.value = "";
        stripPatternInput.value = "";
        folderNameSection.style.display = "none";
        optionsContent.style.display = "none";
        toggleOptionsBtn.textContent = "‚öôÔ∏è Options (click to expand)";
        currentTorrentId = null;
        totalFiles = 0;
      })
      .catch(err => alert("File selection failed: " + err));
  };
  </script>

  <footer id="version-footer" style="text-align:center; margin-top:1em; color:#666; font-size:0.9em;">
    Loading version info...
  </footer>

  <script>
  async function showVersion() {
    try {
      const resp = await fetch('/version');
      const data = await resp.json();
      const footer = document.getElementById('version-footer');
      footer.textContent = `Pullr ‚Äì ${data.branch} @ ${data.commit}`;
    } catch (e) {
      console.error("Failed to fetch version info:", e);
    }
  }
  showVersion();
  </script>

</body>
</html>